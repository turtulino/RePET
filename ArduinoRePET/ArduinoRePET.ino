#include <U8g2lib.h>
#include <PID_v1.h>

// I/O Used pins

// #define D5 5  
// #define D3 3  

#define GATE_PIN D3    // Control heater (MOSFET gate)
#define BUTTON_PIN D5  // Start/Staop

//
// Display info
#define DISPLAY_ROTATION U8G2_R0
#define DISPLAY_WIDTH 128  // OLED display width, in pixels
#define DISPLAY_HEIGHT 64  // OLED display height, in pixels

// For displays with 2 color zones
#define DISPLAY_HEADER_SIZE 16
#define DISPLAY_MAIN_SIZE 48

// Init display object
// U8G2_SH1106_128X64_NONAME_F_HW_I2C u8g2(U8G2_R0);
U8G2_SSD1306_128X64_NONAME_F_HW_I2C u8g2(U8G2_R0);

// Title
String display_title = String("RePET");

const uint8_t ECODECAT[] PROGMEM = {
  0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0xd0, 0x00, 0x00, 0xd8, 0x01, 0x00,
  0xb8, 0x03, 0x00, 0xb8, 0x07, 0x00, 0xbc, 0x0f, 0x00, 0xbc, 0x1f, 0x00,
  0xbc, 0x1f, 0x00, 0x7e, 0x3f, 0x00, 0x7e, 0x3f, 0x38, 0x7e, 0x3f, 0x5e,
  0x7e, 0x3f, 0x6f, 0x7e, 0xbf, 0x77, 0xfe, 0xde, 0x7b, 0xfc, 0xee, 0x7d,
  0xfc, 0xf6, 0x7d, 0xf8, 0xf6, 0x3e, 0xf0, 0x7a, 0x3f, 0xe0, 0xbd, 0x1f,
  0xc0, 0xdd, 0x1f, 0x80, 0xed, 0x0f, 0x00, 0xed, 0x07, 0x00, 0xf4, 0x01
};

const unsigned char TEMP1[] PROGMEM = {
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x00, 0x00, 0xc0, 0x3f, 0x00, 0x00,
  0x00, 0xe0, 0x7a, 0x00, 0x00, 0x00, 0x70, 0xe0, 0x00, 0x00, 0xfc, 0x30,
  0xc0, 0x00, 0x00, 0xfc, 0x19, 0x80, 0x01, 0x00, 0x00, 0x18, 0x82, 0x01,
  0x00, 0x00, 0x18, 0x86, 0x01, 0x00, 0x00, 0x18, 0x86, 0x01, 0x00, 0x00,
  0x18, 0x86, 0x01, 0x00, 0xf0, 0x19, 0x86, 0x01, 0x00, 0xf8, 0x19, 0x86,
  0x01, 0x00, 0x00, 0x18, 0x86, 0x01, 0x00, 0x00, 0x18, 0x86, 0x01, 0x00,
  0x00, 0x18, 0x86, 0x01, 0x00, 0x00, 0x18, 0x86, 0x01, 0x00, 0xfc, 0x19,
  0x86, 0x01, 0x00, 0xfc, 0x19, 0x86, 0x01, 0x00, 0x00, 0x18, 0x86, 0x01,
  0x00, 0x00, 0x18, 0x86, 0x01, 0x00, 0x00, 0x18, 0x86, 0x01, 0x00, 0x00,
  0x18, 0x86, 0x01, 0x00, 0xf8, 0x19, 0x86, 0x01, 0x00, 0xf0, 0x19, 0x86,
  0x01, 0x00, 0x00, 0x18, 0x86, 0x01, 0x00, 0x00, 0x18, 0x86, 0x01, 0x00,
  0x00, 0x18, 0x86, 0x01, 0x00, 0x20, 0x18, 0x86, 0x01, 0x00, 0xfe, 0x19,
  0x86, 0x01, 0x00, 0x6c, 0x19, 0x86, 0x01, 0x00, 0x00, 0x18, 0x86, 0x01,
  0x00, 0x00, 0x18, 0x86, 0x01, 0x00, 0x00, 0x1c, 0x86, 0x03, 0x00, 0x00,
  0x0e, 0x06, 0x07, 0x00, 0x00, 0x07, 0x06, 0x06, 0x00, 0x00, 0x83, 0x1f,
  0x0c, 0x00, 0x00, 0xc3, 0x3f, 0x0c, 0x00, 0x80, 0xc1, 0x3f, 0x1c, 0x00,
  0x80, 0xe1, 0x7f, 0x18, 0x00, 0x80, 0xe1, 0x7f, 0x18, 0x00, 0x80, 0xe1,
  0x7f, 0x18, 0x00, 0x80, 0xe1, 0x3f, 0x08, 0x00, 0x00, 0xc3, 0x3f, 0x0c,
  0x00, 0x00, 0x83, 0x1f, 0x0c, 0x00, 0x00, 0x07, 0x02, 0x06, 0x00, 0x00,
  0x06, 0x00, 0x07, 0x00, 0x00, 0x1c, 0x80, 0x03, 0x00, 0x00, 0x38, 0xc0,
  0x01, 0x00, 0x00, 0xf0, 0xfb, 0x00, 0x00, 0x00, 0xc0, 0x3f, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

const unsigned char TEMP2[] PROGMEM = {
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x00, 0x00, 0xc0, 0x3f, 0x00, 0x00,
  0x00, 0xe0, 0x74, 0x00, 0x00, 0x00, 0x70, 0xe0, 0x00, 0x00, 0xfc, 0x30,
  0xc0, 0x00, 0x01, 0xfc, 0x19, 0x80, 0x81, 0x03, 0x00, 0x18, 0x82, 0xc1,
  0x07, 0x00, 0x18, 0x86, 0xe1, 0x0f, 0x00, 0x18, 0x86, 0x71, 0x1b, 0x00,
  0x18, 0x86, 0x39, 0x3b, 0xf0, 0x19, 0x86, 0x8d, 0x31, 0xf8, 0x19, 0x86,
  0x01, 0x01, 0x00, 0x18, 0x86, 0x81, 0x03, 0x00, 0x18, 0x86, 0x01, 0x01,
  0x00, 0x18, 0x86, 0x81, 0x03, 0x00, 0x18, 0x86, 0x01, 0x01, 0xfc, 0x19,
  0x86, 0x81, 0x03, 0xfc, 0x19, 0x86, 0x01, 0x01, 0x00, 0x18, 0x86, 0x81,
  0x03, 0x00, 0x18, 0x86, 0x01, 0x01, 0x00, 0x18, 0x86, 0x81, 0x03, 0x00,
  0x18, 0x86, 0x01, 0x01, 0xf8, 0x19, 0x86, 0x81, 0x03, 0xf0, 0x19, 0x86,
  0x01, 0x01, 0x00, 0x18, 0x86, 0x81, 0x03, 0x00, 0x18, 0x86, 0x01, 0x01,
  0x00, 0x18, 0x86, 0x81, 0x03, 0x10, 0x18, 0x86, 0x01, 0x01, 0xfe, 0x19,
  0x86, 0x01, 0x03, 0x6c, 0x19, 0x86, 0x01, 0x00, 0x00, 0x18, 0x86, 0x01,
  0x00, 0x00, 0x18, 0x86, 0x01, 0x00, 0x00, 0x1c, 0x86, 0x03, 0x00, 0x00,
  0x06, 0x06, 0x07, 0x00, 0x00, 0x06, 0x06, 0x06, 0x00, 0x00, 0x83, 0x0f,
  0x0c, 0x00, 0x00, 0xc3, 0x3f, 0x0c, 0x00, 0x80, 0xc1, 0x3f, 0x0c, 0x00,
  0x80, 0xe1, 0x7f, 0x18, 0x00, 0x80, 0xe1, 0x7f, 0x18, 0x00, 0x80, 0xe1,
  0x7f, 0x18, 0x00, 0x80, 0xe1, 0x3f, 0x08, 0x00, 0x00, 0xc3, 0x3f, 0x0c,
  0x00, 0x00, 0x83, 0x1f, 0x0c, 0x00, 0x00, 0x07, 0x02, 0x0e, 0x00, 0x00,
  0x06, 0x00, 0x06, 0x00, 0x00, 0x1c, 0x80, 0x03, 0x00, 0x00, 0x38, 0xc0,
  0x01, 0x00, 0x00, 0xf0, 0xfb, 0x00, 0x00, 0x00, 0xc0, 0x3f, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

//
// Temperature reading usin NTC resistor
//

double Temperatura;
float Vo;
float Vo_prev = 0;

// Multiple samples to filter Vo input.
#define VO_SAMPLE_COUNT 10
bool vo_init = false;
int vo_sample_index = 0;
float vo_sample_buffer[ VO_SAMPLE_COUNT ];
float vo_sample_sum = 0;
float vo_sample_average = 0;
float vo_sample_average_prev = 0;


float R1 = 1000;  // resistencia fija del divisor de tension
float logR2, R2;
double TEMPERATURA;
double TEMPERATURAPANTALLA;
float c1 = 0, c2 = 0, c3 = 0;

// coeficientes de S-H en pagina:
// http://www.thinksrs.com/downloads/programs/Therm%20Calc/NTCCalibrator/NTCcalculator.htm

int c = 0;
int pressedPrev = LOW; // Previous pressed status
bool ESTAT = false;


float TEMPERATURAANT = 0;
unsigned long tiempoAnterior = 0;
int contador = 0;
int contador2 = 0;
int tempo = 0;
int conta1 = 0;
int conta2 = 0;


// Controls screen refresh
bool firstLoop = true;
double lastTimeUpdated = 0;


double Setpoint;  // will be the desired value
double Input;     //
double Output;    // Controls heater value

// PID parameters
double agrKp = 6, agrKi = 0, agrKd = 0;
double conKp = 12, conKi = 0.3, conKd = 0;
double Max = 255;  // Not sure if this works with other value.

PID myPID(&Input, &Output, &Setpoint, conKp, conKi, conKd, DIRECT);


//
// INIT
//

void setup() {
  u8g2.begin();
  u8g2.setDisplayRotation(DISPLAY_ROTATION);

  Serial.begin(9600);
  
  pinMode(BUTTON_PIN, INPUT);

  Setpoint = 60;

  myPID.SetMode(AUTOMATIC);
  myPID.SetOutputLimits(GATE_PIN, Max);
}


//
// MAIN LOOP
//

void loop() {
  UPDATE_SCREEN();
  THERMISTOR();
  ENABLE();
  PIDCONTROL();
}


//
//
//

void UPDATE_SCREEN() {

  if (firstLoop) {
    show_intro_logo();
    firstLoop = false;
  } else {

    // Update every second
    unsigned long now = millis();

    if ((now - lastTimeUpdated) > 500) {
      show_status();
      lastTimeUpdated = now;
    }
  }
}

void ENABLE() {
  int pressed = digitalRead( BUTTON_PIN );

  if (pressed == HIGH && pressedPrev == LOW) {
    ESTAT = !ESTAT;
  }

  pressedPrev = pressed;

}


void THERMISTOR() {
  float ema_alpha = .1;

  // Read value
  uint read = analogRead(A0);    
  delay(10);

  // Init vo_sample buffer (if is first time)
  if( !vo_init ) {
    vo_init = true;
    for( int i = 0; i < VO_SAMPLE_COUNT; i++ ) vo_sample_buffer[i] = read;
    vo_sample_sum = (float)read * VO_SAMPLE_COUNT;
    vo_sample_average_prev = (float)read;
  }

  // Calculate average
  vo_sample_sum -= vo_sample_buffer[ vo_sample_index ];
  vo_sample_buffer[ vo_sample_index ] = (float)read;
  vo_sample_sum += (float)read;

  // Change index
  vo_sample_index = ( vo_sample_index + 1 ) % VO_SAMPLE_COUNT;

  // Recalc average
  vo_sample_average = vo_sample_sum / VO_SAMPLE_COUNT;
  
  // Apply EMA filter
  Vo = ema_alpha * vo_sample_average + (1 - ema_alpha) * vo_sample_average_prev ;
  vo_sample_average_prev = Vo;


  // Calc NTC resistor value. 
  //   Note: Depending of connection, expresion could be: R2 = R1 * ((1023.0) / (float)Vo - 1.0);  
  R2 = R1 * ( ( 1023.0 / Vo ) - 1 ); 

  logR2 = log(R2);
  
  // if (R2 < 10500) {
    c1 = 0.9188169704e-03;
    c2 = 2.018954414e-04; 
    c3 = 0.7999925558e-07;
  // } 
  // else {
  //   c1 = -3.532779690e-03;
  //   c2 = 8.606773781e-04;
  //   c3 = -19.80406727e-07;
  // }

  //
  //  Steinhart-Hart equation: 
  //  1/T = c1 + c2 * logR + c3 * logR^3
  // TEMPERATURA = (1.0 / (c1 + c2 * logR2 + c3 * logR2 * logR2 * logR2));  // temperature in Kelvin
  // TEMPERATURA = TEMPERATURA - 273.15;                                    // convert Kelvin to Celcius


  TEMPERATURA = (1.0 / (c1 + c2 * logR2 + c3 * pow( logR2, 3 ) ) );  // temperature in Kelvin
  TEMPERATURA = TEMPERATURA - 273.15;                              // convert Kelvin to Celcius


  Serial.printf( "Read D0:%d,Vo:%f,R_NTC:%f,Temp:%f\n", read, Vo, R2, TEMPERATURA );

  // Serial.println(TEMPERATURA);
  if (TEMPERATURA < 0) {
    TEMPERATURA = 0;
  }

  if (-2 <= (TEMPERATURA - TEMPERATURAANT) <= 2) {

  } else {
    TEMPERATURA = TEMPERATURAANT;
  }

  TEMPERATURAANT = TEMPERATURA;

  contador = contador + 1;
  if (contador == 5) {
    TEMPERATURAPANTALLA = TEMPERATURA;
    contador = 0;
  }
}



void PIDCONTROL() {

  Input = TEMPERATURA;

  if ( ESTAT ) {

    contador2 = contador2 + 1;
    if (contador2 == 5) {
      double gap = abs(Setpoint - TEMPERATURA);
      // if (gap < 20) {
      //   myPID.SetTunings(conKp, conKi, conKd);
      // } else {
        myPID.SetTunings(agrKp, agrKi, agrKd);
      // }
      myPID.Compute();
      contador2 = 0;
    }

    // Inverts output (because logit is inverted in hardware: pnp + mosfet with pull-up)
    analogWrite(GATE_PIN, Max - Output);
    digitalWrite( LED_BUILTIN, HIGH );
  }
  else {
    // Inverts output (because logit is inverted in hardware: pnp + mosfet with pull-up)
    // Max value => gate-closed
    analogWrite(GATE_PIN, Max);
    digitalWrite( LED_BUILTIN, LOW );
  }


  Serial.printf("PID_Output:%f\n", Output );

}


void show_intro_logo() {

  u8g2.firstPage();

  do {

    u8g2.setFont(u8g2_font_spleen16x32_mu);
    u8g2.setCursor(0, 55);
    u8g2.println("ECODECAT");
    u8g2.drawXBMP(27, 5, 24, 24, ECODECAT);

  } while (u8g2.nextPage());

  delay(1000);
}

void show_status() {

  u8g2.firstPage();

  do {

    // Current temperature
    show_temperature(TEMPERATURAPANTALLA, 60, DISPLAY_HEADER_SIZE + 16 + 4);

    // Target temperature
    show_temperature(Setpoint, 60, DISPLAY_HEADER_SIZE + 46);

    // Thermomether ICON
    if (ESTAT) {
      if (conta2 < 30) {
        u8g2.drawXBMP(5, 4, 40, 64, TEMP1);
        conta2 = conta2 + 1;
      } else {
        u8g2.drawXBMP(5, 4, 40, 64, TEMP2);
        conta2 = conta2 + 1;
        if (conta2 == 70) {
          conta2 = 0;
        }
      }
    }

    // Extra info in header
    show_header();

  } while (u8g2.nextPage());
}

void show_temperature(double value, int x, int y) {

  u8g2.setFont(u8g2_font_inb16_mf);
  u8g2.setCursor(x, y);

  char t[7];
  sprintf(t, "%3d%cC", (int)value, 176);  // 3 digits, º and "C".
  u8g2.print(t);
}

void show_header() {

  u8g2.setFont(u8g2_font_6x13_tr);
  u8g2.setCursor(DISPLAY_WIDTH - (display_title.length() * 6), DISPLAY_HEADER_SIZE - 6);
  u8g2.print(display_title);
}
